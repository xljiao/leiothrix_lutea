###***********************************************************************************************
###
### parseVCF.py
### Simon Martin (shm45@cam.ac.uk)
###
###***********************************************************************************************
###
### Script to convert a VCF into a genotype "calls" file with the following format:
###
### scaffold  position  ind1  ind2  ind3  etc...
### scf1  1 T T C Y
###
### NOTE: only tested on vcfs generated by GATK 2 and 3 UnifiedGenotyper
###
###***********************************************************************************************
###
### USAGE
###
### python ~/scripts/parseVCF-0.1.py -v input.vcf -o output.calls -gq 30 -d 10 -m geno
###
### -Q <int> filters for sites with QUAL greater than or equal to int
### -gq <int> filters for sites with genotype quality greater than or equal to int
### -d <int> sets the minimum depth cutoff per individual at int
### -D <int> sets the maximum depth cutoff per individual at int
### -m <mode> Determines the output format
###    "geno" gives a single genotype per individual, eg "A" or "W" (heterozygous A,T)
###    "haplo" gives two haplotypes per individual (SPLIT ARBITRARILY - these are NOT TRUE HAPLOTYPES)
###    "phased" gives the two genotypes separarated by the phase oporator ("/" or "|"). This will only be useful is some dsort of phasing has already been done on the vcf
###
### --biallelic for only biallelic sites
### --minCalls <int> will only output sites where there is a non-N call for at least int samples
### --sep <space/comma/tab> separator in the output file. Default is tab.
###***********************************************************************************************
###***********************************************************************************************


import sys
import time
import gzip

def getOptionValue(option): # needs sys
  if option in sys.argv:
    optionPos = sys.argv.index(option)
    optionValue = sys.argv[optionPos + 1]
    return optionValue
  else:
    print >> sys.stderr, "\nWarning, option", option, "not_specified.\n"

def geno(hap1,hap2):
  hap1 = hap1.upper()
  hap2 = hap2.upper()
  if hap1 not in "ACGT" or hap2 not in "ACGT":
    return "N"
  elif hap1 == hap2:
    return hap1
  else:
    geno = sorted([hap1,hap2])
    if geno == ["A","C"]:
      return "M"
    elif geno == ["A","G"]:
      return "R"
    elif geno == ["A","T"]:
      return "W"
    elif geno == ["C","G"]:
      return "S"
    elif geno == ["C","T"]:
      return "Y"
    elif geno == ["G","T"]:
      return "K"




if "--test" in sys.argv:
  test = True
else:
  test = False

# read vcf file

if "-v" in sys.argv:
  vcfName = getOptionValue("-v")
else:
  print "\nplease specify vcf file name using -v <file_name> \n"
  sys.exit()

# open output 

if "-o" in sys.argv:
  outName = getOptionValue("-o")
else:
  print "\nplease specify output file name using -o <file_name> \n"
  sys.exit()


# check mode

if "-m" in sys.argv:
  mode = getOptionValue("-m")
  if mode != "phased" and mode != "geno" and mode != "haplo" and mode != "freq":
    print "mode can be 'phased', 'geno', 'haplo' or 'freq'."
else:
  print "\nplease specify mode using -m \n"
  sys.exit()


# check filter

if "-F" in sys.argv:
  filter = True
  filters = getOptionValue("-F").split(",")
else:
  filter = False


if "--biallelic" in sys.argv:
  biallelic = True
else:
  biallelic = False


if "--gzipIn" in sys.argv:
  gzipIn = True
else:
  gzipIn = False

if "--gzipOut" in sys.argv:
  gzipOut = True
else:
  gzipOut = False


if "-Q" in sys.argv:
  checkQual = True 
  minQUAL = int(getOptionValue("-Q"))
else:
  checkQual = False


if "-DP" in sys.argv:
  checkDP = True
  minOverallDepth = int(getOptionValue("-DP"))
else:
  checkDP = False



# check format filters
formatFiltering = False
gqCut = 1
minDepth = 1
maxDepth = 10000


if "-gq" in sys.argv:
  gqCut = int(getOptionValue("-gq"))
  formatFiltering = True

if "-d" in sys.argv:
  minDepth = int(getOptionValue("-d"))
  formatFiltering = True

if "-D" in sys.argv:
  maxDepth = int(getOptionValue("-D"))
  formatFiltering = True

if "--sep" in sys.argv:
  if getOptionValue("--sep") == "comma":
    sep = ","
  elif getOptionValue("--sep") == "tab":
    sep = "\t"
  elif getOptionValue("--sep") == "space":
    sep = " "
  else:
    print "\nThe only options for --sep are 'comma', 'tab' or 'space'\n"
    sys.exit()
    
else:
  sep = "\t"

if "--minCalls" in sys.argv:
  minCalls = int(getOptionValue("--minCalls"))
else:
  minCalls = 0


#start reading

if gzipIn:
  vcf = gzip.open(vcfName, "r")
else:
  vcf = open(vcfName, "r")

if gzipOut:
  out = gzip.open(outName, "w")
else:
  out = open(outName, "w")


line = vcf.readline()
while line[0] == "#" and line [0:6] != "#CHROM":
  line = vcf.readline()

headers = line.split()

indNames = headers[9:]

out.write("scaffold" + sep + "position")
for name in indNames:
  if mode == "phased" or mode == "geno" or mode == "freq":
    out.write(sep + name)
  elif mode == "haplo":
    out.write(sep + name + "_A" + sep +  name + "_B")
out.write("\n")

line = vcf.readline()
linesDone = 1

while len(line) > 1:
  objects = line.split()
  
  #do filtering of whole site
  if filter:
    if objects[6] in filters:
      OK = True
    else:
      OK = False
  else:
    OK = True
  
  #remove mult--allelic sites
  if biallelic and len(objects[4]) > 1:
    OK = False
  
  info = objects[7].split(";")
  freq = None
  if checkDP:
    #filter for overall depth
    for element in info:
      if "DP=" in element:
        overallDepth = int(element.split("=")[-1])
        if overallDepth < minOverallDepth:
          OK = False
    
  format = objects[8].split(":")
  
  if checkQual:
    try:
      if float(objects[5]) < minQUAL:
        OK = False
    except:
      print line
      sys.exit()
  
  #do filtering per individual and writing
  if OK:
    if formatFiltering:
      if "DP" in format:
        dpPos = format.index("DP")
      if "GQ" in format:
        gqPos = format.index("GQ")
    
    
    outObjects = objects[0:2]
    
    if mode == "phased" or mode == "geno" or mode == "haplo":
      ref = [objects[3]]
      alts = objects[4].split(",")
      alleles = ref + alts
      
      goodCalls = 0
      
      for data in objects[9:]:
        splitData = data.split(":")
        gt = splitData[0]
        if gt[0] == ".":
          hap1 = "N"
          hap2 = "N"
          phase = "|"
        elif formatFiltering:
          depth = int(splitData[dpPos])
          if depth < minDepth:
            hap1 = "N"
            hap2 = "N"
            phase = "|"
            #notDeep += 1
          elif depth > maxDepth:
            hap1 = "N"
            hap2 = "N"
            phase = "|"
            #tooDeep += 1
          elif "GQ" in format and splitData[gqPos] != "." and float(splitData[gqPos]) < gqCut:
            hap1 = "N"
            hap2 = "N"
            phase = "|"
            #badQual += 1
          else:
            hap1 = alleles[int(gt[0])]
            hap2 = alleles[int(gt[2])]
            phase = gt[1]
            goodCalls += 1
        else:
          hap1 = alleles[int(gt[0])]
          hap2 = alleles[int(gt[2])]
          phase = gt[1]
          goodCalls += 1
        #add to outObjects
        if mode == "phased":
          outObjects.append(hap1+phase+hap2)
        elif mode == "haplo":
          outObjects.append(hap1)
          outObjects.append(hap2)
        elif mode == "geno":
          outObjects.append(geno(hap1,hap2))
      if goodCalls >= minCalls:
        out.write(sep.join(outObjects) + "\n")
    
    elif mode == "freq":
      freq = "NA"
      if objects[4] == ".":
        freq = 0.0
      else:
        for element in info:
          if "AF=" in element:
            freq = float(element.split("=")[-1])
      out.write(sep.join(outObjects) + sep + str(freq) + "\n")
  
  line = vcf.readline()
  linesDone += 1
  if linesDone % 1000000 == 0:
    print linesDone, "lines done..."

vcf.close()
out.close()


